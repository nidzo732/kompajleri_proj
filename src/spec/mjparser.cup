package rs.ac.bg.etf.pp1.ast;
import rs.ac.bg.etf.pp1.Yylex;
import rs.ac.bg.etf.pp1.CompilerError;
import java_cup.runtime.Symbol;
parser code {:
    @Override
    protected int error_sync_size()
    {
        return 1;
    }

    @Override
    public void syntax_error(Symbol cur_token)
    {
        System.err.println("Warning");
        System.err.println("Error found at Line:"+((Yylex)getScanner()).getLineNo()+" Column:"+((Yylex)getScanner()).getColumn());
        System.err.println("Attempting to recover\n");
    }

    @Override
    public void unrecovered_syntax_error(Symbol cur_token) throws Exception {
        CompilerError.raise("Unfixable syntax error", ((Yylex)getScanner()).getLineNo(), ((Yylex)getScanner()).getColumn());
    }
:}

terminal int NUMBER;
terminal char CHARACTER;
terminal PROGRAM;
terminal BREAK;
terminal CLASS;
terminal ELSE;
terminal IF;
terminal NEW;
terminal RETURN;
terminal VOID;
terminal DO;
terminal WHILE;
terminal EXTENDS;
terminal CONTINUE;
terminal String IDENT;
terminal boolean BOOL;
terminal CONST;

terminal PLUS, MINUS, STAR, DIVIDE, MOD;
terminal EQUALS, NOTEQUALS, GREATER, GREATEREQUAL, LESS, LESSEQUAL;
terminal AND, OR;
terminal ASSIGN;
terminal INCREMENT, DECREMENT;
terminal SEMICOLON;
terminal COMA;
terminal LPAREN, RPAREN;
terminal LBRACE, RBRACE;
terminal LBRACK, RBRACK;
terminal DOT;

nonterminal rs.ac.bg.etf.pp1.TypeAnnotation factor;
nonterminal rs.ac.bg.etf.pp1.TypeAnnotation designator;
nonterminal rs.ac.bg.etf.pp1.TypeAnnotation term;
nonterminal rs.ac.bg.etf.pp1.TypeAnnotation expr;
nonterminal rs.ac.bg.etf.pp1.TypeAnnotation type;
nonterminal actpars;
nonterminal rs.ac.bg.etf.pp1.TypeAnnotation condterm;
nonterminal rs.ac.bg.etf.pp1.TypeAnnotation condfactor;
nonterminal rs.ac.bg.etf.pp1.TypeAnnotation condexpr;
nonterminal designatorstmt;
nonterminal statement;
nonterminal statementblock;
nonterminal formpars;
nonterminal formparswrapper;
nonterminal namedeclaration;
nonterminal variabledeclaration;
nonterminal function;
nonterminal declarationblock;
nonterminal declarationblockwrapper;
nonterminal constnamedeclaration;
nonterminal constantdeclaration;
nonterminal codebody;
nonterminal classdeclaration;
nonterminal programdeclarations;
nonterminal program;
nonterminal rs.ac.bg.etf.pp1.TypeAnnotation call;
nonterminal extendsdeclaration;
nonterminal rs.ac.bg.etf.pp1.TypeAnnotation classname;
nonterminal rs.ac.bg.etf.pp1.TypeAnnotation functionname;
nonterminal rs.ac.bg.etf.pp1.TypeAnnotation programname;
nonterminal errsep;
nonterminal designatorline;

program     ::= PROGRAM programname:name programdeclarations LBRACE codebody RBRACE
                ;

programname ::= (ProgramName) IDENT:name
                ;
classname ::= (ClassName) IDENT:name
              ;
functionname ::= (FunctionName) IDENT:name
            ;

programdeclarations     ::=
                            | programdeclarations classdeclaration
                            | programdeclarations constantdeclaration SEMICOLON
                            | programdeclarations variabledeclaration SEMICOLON
                            ;

extendsdeclaration  ::=     IDENT:base LBRACE
                         |  IDENT:base error LBRACE
                         ;

classdeclaration    ::=   (DerivedClass) CLASS classname:name EXTENDS extendsdeclaration declarationblockwrapper codebody RBRACE RBRACE
                        | (NonDerivedClass) CLASS classname:name LBRACE declarationblockwrapper codebody RBRACE RBRACE
                        ;
codebody   ::=
                | codebody function
                ;

function    ::=    (Func) type functionname:name formparswrapper declarationblock LBRACE statementblock RBRACE
                 | (Proc) VOID functionname:name formparswrapper declarationblock LBRACE statementblock RBRACE
                 ;

declarationblockwrapper ::=   (DeclarationBlockWrapper1) declarationblock LBRACE
                            | (DeclarationBlockWrapper2) declarationblock error LBRACE
                            ;

declarationblock ::=   (DeclarationBlock) declarationblock variabledeclaration SEMICOLON
                     | (EmptyDeclarationBlock)
                     ;

formparswrapper ::=      (FormParsWrapper) LPAREN formpars RPAREN
                       | (FormParsWrapper2) LPAREN error COMA formpars RPAREN
                       | (FormParsWrapper3) LPAREN error RPAREN
                    ;

formpars    ::=   formpars COMA type namedeclaration
                | formpars COMA error
                | type namedeclaration
                |
                ;

constantdeclaration ::=   (ConstantDeclarations) constantdeclaration COMA constnamedeclaration
                        | (ConstantDeclarationTyped) CONST type constnamedeclaration
                        ;

variabledeclaration ::=     type namedeclaration
                          | variabledeclaration COMA namedeclaration
                          | variabledeclaration COMA error
                          | type error
                          ;

constnamedeclaration    ::=   (BoolConstantDeclaration) IDENT:name ASSIGN BOOL:val
                            | (CharConstantDeclaration) IDENT:name ASSIGN CHARACTER:val
                            | (NumberConstantDeclaration) IDENT:name ASSIGN NUMBER:val
                            ;

namedeclaration     ::=   (Variable) IDENT:name
                        | (Array) IDENT:name LBRACK RBRACK
                        ;

statement   ::=       designatorline
                    | (Block) LBRACE statementblock RBRACE
                    | (If) IF LPAREN condexpr RPAREN statement
                    | (Else) ELSE statement
                    | (DoWhile) DO statement WHILE LPAREN condexpr RPAREN SEMICOLON
                    | (Break) BREAK SEMICOLON
                    | (Continue) CONTINUE SEMICOLON
                    | (Return) RETURN expr SEMICOLON
                    | (EmptyReturn) RETURN SEMICOLON
                    | (CallStatement) call SEMICOLON
                    ;

statementblock  ::=   (EmptyBlock)
                    | (StatementBlock) statementblock statement
                    ;

designatorline  ::=   designatorstmt SEMICOLON
                    | designatorstmt error SEMICOLON
                    | error SEMICOLON
                    ;

designatorstmt  ::=   (Assign) designator ASSIGN expr
                    | (Increment) designator INCREMENT
                    | (Decrement) designator DECREMENT
                    ;

condexpr ::=   (SingleCondExpr) condterm
             | (Or) condexpr OR condterm
             | (CondExprError) condexpr OR error
             ;

condterm ::=  (SingleCondTerm) condfactor
            | (And) condterm AND condfactor
            | (CondTermError) condterm AND error
            ;

condfactor::= (SingleCondFactor) expr
            | (Equals) expr EQUALS expr
            | (NotEquals) expr NOTEQUALS expr
            | (Greater) expr GREATER expr
            | (GreaterEqual) expr GREATEREQUAL expr
            | (Less) expr LESS expr
            | (LessEqual) expr LESSEQUAL expr
            ;

errsep  ::= OR | AND |EQUALS|GREATER|GREATEREQUAL|LESS|LESSEQUAL|DECREMENT|INCREMENT|
            |IDENT|COMA
            ;

expr   ::=    (SingleExpr) term
            | (Addition) expr PLUS term
            | (Substraction) expr MINUS term
            ;

term   ::=   (SingleTerm) factor
           | (Negated) MINUS factor
           | (Multiplication) term STAR factor
           | (Division) term DIVIDE factor
           | (Modulus) term MOD factor
           ;

call   ::= (FuncCall) designator LPAREN actpars RPAREN;

factor ::=   (NumericConstant) NUMBER:val
           | (CharacterConstant) CHARACTER:val
           | (BooleanConstant) BOOL:val
           | (SingleFactor) designator
           | (NewObject) NEW type
           | (NewArray) NEW type LBRACK expr:count RBRACK
           | (Parenthesized) LPAREN expr RPAREN
           | (CallResult) call
           ;

designator  ::=   (BaseDesignator) IDENT:name
                | (PathDesignator) designator DOT IDENT:name
                | (IndexDesignator) designator LBRACK expr RBRACK
            ;

type        ::= (Type) IDENT:name
            ;

actpars     ::=   (Parameter) expr
                | (Parameters) actpars COMA expr
                | (EmptyParameters)
                ;
