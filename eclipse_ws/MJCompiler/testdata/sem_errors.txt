program P

interface I1
{
}
interface I2
{
	int x(int a);
}
interface I3
{
	int x();
}
// izvodjenje iz primitiva
class K1 extends char
{
}
// izvodjenje iz interfejsa
class K2 extends I1
{
}
// dupla implementacija istog interfejsa
class K3 implements I1, I1
{
}

// implementacija nekompatibilnih interfejsa
class K4 implements I2, I3
{
	{
		int x(){ return 42;}
		
	}
}

// implementacija, fali metoda
class K5 implements I2
{
	{
		
		
	}
}

// type-mismatch
const int a=42, b='A';
const char c=55;

// enum sa duplikatima
enum E{V1, V1=13, V3=13}

// ispravan enum
enum E2{V1, V2, V3}
{
	void f()
	{
		// nepostojeci this
		if(this==null) {}
	}
	// upotreba promenljive na mestu tipa
	void f(a b)
	c d;
	{
	}
	
	int z(int a, int b)
	{
		return 42;
	}
	
	// main sa losim potpisom
	int main()
	int x;
	char ch;
	int arr[];
	E2 enm;
	I3 i3;
	{
		if(42){}
		for(x=0;42+3;x=13)
		{
		}
		
		// visak/manjak/neispravni parametri
		z(5);
		z(5,6,7);		
		z('A',4);
		
		// van petlje
		break;
		continue;
		
		// citanje konstante
		read(a);
		read(E2.V1);
		
		
		// modifikovanje konstante
		E2.V1=42;
		E2.V1=E2.V2;
		a=42;
		a++;
		E2.V1++;
		E2.V1--;
		a--;
		
		// negacija non-int tipa
		ch=-'A';
		
		// indeksiranje skalara
		print(a[0]);
		print(x[4]);
		
		// upotreba niza kao skalara
		arr=42;
		
		// dinamicko instanciranje non-class tipa
		ch= new char;
		x= new int;
		enm=new E2;
		i3=new I3;
		
		// indeksiranje non-int tipom
		arr['A']=42;
		arr[i3]=88;
		
		// pristup nepostojecim poljima
		i3.a=42;
		arr.p=88;
		x.b=7;
		E2.pp=8;
		
		// upotreba tipova u izrazima
		i3=I3;
		enm=E2;
		if(E2==E2.V1){}
		
		
		// aritmetika sa non-int tipovima
		i3=i3+42;
		enm=E2.V1+4;
		x='A'+7*i3;
		
		// bool aritmetika sa non-boolean tipovima
		if(x+3){}
		if(x&&42){}
		if(x&&x>3){}
		if(x||x>3){}
	}
}